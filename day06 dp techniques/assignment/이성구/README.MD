
문제 설명: 

n가지 종류의 동전이 있고, 이 동전들의 가치는 모두 각각 다르다. 이 동전들을 사용해서 가치의 합이 k원이 되도록 하자.
1. 순서는 고려하지 않음: 1 2 1 과 2 1 1 이 같음.
2. 사용하지 않거나 중복하는 것 둘다 허용함. 
3. 시간복잠도는 0.5초 메모리는 4MB임.
4. 1<= n <= 100, 1<= k <= 10000


예제 입력: 맨 앞줄에 n과 k을 입력받고 n줄만큼 동전들의 가치를 입력받음.
3 10
1 
2
5

이들의 방법은 총 10가지 아래와 같다.
1. 5 5
2. 5 2 2 1
3. 5 2 1 1 1
4. 5 1 1 1 1 1
5. 2 2 2 2 2 
6. 2 2 2 2 1 1 
7. 2 2 2 1 1 1 1
8. 2 2 1 1 1 1 1 1
9. 2 1 1 1 1 1 1 1 1
10. 1 1 1 1 1 1 1 1 1 1

이제 문제를 다 이해했을거라고 생각 한다.

우선 중복되는 값을 찾아보자.

-> dp[10001]으로 설정. 배열에는 인덱스 값에 해당하는 동전들의 경우의 수를 저장한다. 즉 dp[100]이면 100일때 입력으로 받은 동전들의 조합으로 얻을 수 있는 경우의 수를 저장한다.

dp[k]이면 우리가 구해야할 답이 됩니다.

위의 예시 입력에서 dp[1]이면 1이 되고 dp[2]이면 {1,1}과 {2}때문에 2가 됩니다. dp[3]이면 {1,1,1},{1,2},{3}으로 3이 됩니다.

이러한 메모리제이션을 통해서 dp[k]을 구하면 될거 같다.

그러면 점화식을 작성해 봅시다.

dp에는 경우의 수를 저장해야 하는데, 이를 위해서 누적합을 사용해 봅시다.  

반복문 안의 코드: 
dp[money] += dp[money - coin[i]];

money크기의 경우의 수를 구하기 위해선 이전 반복문의 money - coin[i]의 경우의 수와 이번 반복문에서의 경우의 수를 더하면 됩니다.

| 동전의 가치  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| - | - | - | - | - | - | - | - | - | - | -- |
|1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1  |
| 2| 1 | 2 | 2 | 3 | 3 | 4 | 4 | 5 | 5 | 6  |
| 5| 1 | 2 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 10 |



```C++
int n, k;

int dp[10001];


void solve(int testcase) {
    cin >> n >> k;
    vector<int> coin(n);
    for(auto & x: coin) cin>>x;
    
    ::memset(dp,0,sizeof(dp));
    dp[0] = 1;
    for (int i = 0; i < n; i++) {
        for (int money = coin[i]; money <= k; money++) {
            if (dp[money - coin[i]]) dp[money] += dp[money - coin[i]];
        }
    }
    cout << dp[k];
}

int main() {
    fast_io;
    solve(1);
    return 0;
}
```
