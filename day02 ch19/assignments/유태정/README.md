[11899. 괄호 끼워넣기](https://www.acmicpc.net/problem/11899)

## 문제요약

올바르지 않은 괄호열이 다음과 같이 주어집니다.

`)))()`

이를 올바른 괄호열로 바꾸려면 왼쪽에 3개의 여는 괄호를 추가하면 되겠죠.

`((())))))()`

물론, 여기에 괄호 쌍을 마구잡이로 붙여도 올바른 괄호열이 됩니다.

`((())))))()()()()()()()()...`

이러면 끝도 없으니 올바른 괄호열로 만들기 위해 필요한 괄호의 **최소 개수**를 구해봅시다.

위의 경우에선 3개가 됩니다.

## 풀이

생각했던 것보다 무척 쉽게 풀렸습니다.

1. 괄호열에서 괄호를 하나 씩 입력 받으며 스택에 넣습니다.
2. 스택의 top과 입력 받은 괄호가 쌍을 이룬다면 스택에서 pop을 합니다.
3. 입력을 모두 다 받고난 뒤 스택의 크기가 곧 답입니다.

## 코드

[바로가기](11899.cc)

## 겪었던 난항

`while`문 조건에 `cin.eof()`를 적으면 마지막 문자가 한 번 더 입력되는 문제를 겪었습니다.

```C++
#include <iostream>
using namespace std;

int main() {

  char c;

  while (!cin.eof()) {
    cin >> c;
    cout << c << endl;
  }

  return 0;
}
```

예를 들어, `)))()`가 입력되어 한 문자씩 출력하면 `)`, `)`, `)`, `(`, `)`, `)`으로 출력이 됩니다.

이를 해결하기 위한 방법은 두 가지가 있습니다.

1. 문자열을 한 번에 입력 받기
2. `cin`의 `>>` 연산자 반환 값을 이용하여 입력의 끝을 판별합니다.

본문에서는 1번 방법을 이용했지만 2번 방법도 이용이 가능합니다.

`cin`의 `>>` 연산자는 `cin` 객체 자체를 *반환*합니다.

> 여기서 `>>` 연산자는 `cin` 객체에서 오버로드 된 연산자이므로 **함수**입니다!
>
>> Overloaded operators are functions with special function names
>>
>> \- [cppreference.com](https://en.cppreference.com/w/cpp/language/operators)

만약, 모종의 이유로 입력 버퍼에서 값을 읽어들이는데 실패하면 `NULL`을 반환합니다.

그래서 입력 버퍼가 비어있어 값을 읽어들이는 데에 실패하면 조건이 거짓이 되어 반복을 탈출할 수 있게 됩니다.

위의 코드가 의도대로 동작하지 않았던 이유는 **`cin`의 `eof` 플래그는 `>>` 연산자가 수행될 때 설정되기 때문입니다.**


### `>>` 연산자가 `NULL`을 반환했는데, 마지막 입력 값이 저장된 이유

그것은 놀랍게도 `>>` 연산자를 수행하기 전 **초기화를 하지 않았기 때문입니다.** 😅
