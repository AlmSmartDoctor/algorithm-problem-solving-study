# dfs (깊이 우선 탐색, depth first search)

## 그래프가 뭐지?

- dfs에 대해 설명하기 전에, 그래프에 대해서 간략하게 생각해봅시다. 교재에서는 **'그래프'에 대한 깊이 우선 탐색**에 대해 설명하고 있기 때문에 그래프에 대해서 이해하는 것이 굉장히 중요합니다.

![사진](https://ifh.cc/g/yyqS1P.png)

- **G(V, E)** -> 그래프(G)는 정점(Vertex)와 간선(Edge)로 구성되어 있는 자료구조입니다.

![사진](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7hNCY%2FbtqzR3amxac%2F40kpXWRQhOOLeYJS7tSZ9K%2Fimg.png)

- 그래프는 방향 그래프(directed graph)와 무향 그래프(undirected graph)로 나뉩니다.

![사진](https://1.bp.blogspot.com/-FPcoUv0_TTE/VXbwkrpH0cI/AAAAAAAB-us/PRKCNN63Q6c/s1600/mstgraph1106.png)

- 다른 중요한 개념으로는 가중치 그래프(weighted graph)가 있습니다. 이 속성은 두 도시 사이의 거리나 두 물건 사이의 교환 비율, 두 사람 사이의 호감도 등 다양한 정보를 표현하는데 사용되며, 최소 스패닝 트리 문제, 최단 경로 문제에서 중요하게 사용됩니다.

![사진](https://3.bp.blogspot.com/-G6qWlqA43Vw/VXcPNnvBOmI/AAAAAAAB-u8/r2xieXw4qck/s1600/%25EB%258B%25A4%25EC%259A%25B4%25EB%25A1%259C%25EB%2593%259C%2B%25282%2529.png)

- 그래프의 '**경로**'에 대해 알아봅시다.
- **A -> B -> C -> E -> F**는 경로일까?
- **A -> B -> D -> E**는 경로일까?
- 경로 중 한 정점을 최대 한 번만 지나는 경로를 '**단순 경로**'라고 부릅니다.

#### **그래프의 사용 예시:** 철도망의 안정성 분석, 소셜 네트워크 분석, 인터넷 전송 속도, 한 붓 그리기, 외환 거래

- 현실 세계에서는 쉽게 해결할 수 없는 문제들이 그래프를 사용하면 쉽게 해결할 수 있는 문제들이 종종 존재합니다.

### 그래프의 표현 방법

- 그래프는 트리에 비해서 **정적** -> **변화가 별로 없다!** -> 구조의 변경이 어렵더라도 좀 더 간단하고 메모리를 적게 차지하는 방법으로 구현하는 편입니다.

- 그래프를 표현하는 방식은 크게 두 가지인데, **어떤 방식을 선택하느냐에 따라 메모리나 시간 사용 특성이 굉장히 달라집니다.** 올바른 표현 방식이야말로 프로그램의 성능에 큰 영향을 미칠 수 있습니다.

- 그래프의 두 가지 표현 방식: **인접 리스트 vs 인접 행렬** 한 방식의 단점이 다른 방식의 장점입니다!

#### 인접 행렬

![인접 행렬](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F21029250584C0F2413)

- **장점:** 정점 u, v가 있을 때, 두 정점을 한번에 이어주는 간선이 있는 지에 대한 여부를 한번에 파악하는 것이 가능합니다. 이는 하나의 정점을 알면, 다른 정점까지 계속 탐색해야 하는 연결리스트는 가지지 못한 장점입니다.

- **단점:** 공간을 상당히 많이 차지합니다. 인접리스트는 O(|V|+|E|)의 공간복잡도만을 가지면 되지만, 연결 리스트는 O(V^2)만큼의 공간을 차지해야 합니다.

#### 인접 리스트

![인접 리스트](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F265E074D584C26DD2B)

- 인접 행렬과 장단점을 서로 뒤바꾸면 된다.

## DFS는 무엇인가?

- 탐색 알고리즘 중 하나로, 현재 정점과 인접한 간선들을 하나씩 검사하다가 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그 간선을 무조건 따라갑니다.
- 막혀있을 때까지 따라간 다음, 더 이상 갈 곳이 없는 경우에는 마지막에 따라왔던 간선을 따라 뒤로 돌아갑니다.

![dfs](https://ifh.cc/g/8pORxB.jpg)

```C++
// 그래프의 인접 리스트 표현
vector<vector<int> > adj;
// 각 정점을 방문했는지 여부를 나타낸다.
vector<bool> visited;
// 깊이 우선 탐색을 구현한다.
void dfs(int here){
    cout << "DFS visits " << here << endl;
    visited[here] = true;
    // 모든 인접 정점을 순회하면서
    for(int i = 0; i < adj[here].size(); ++i){
        int there = adj[here][i];
        // 아직 방문한 적 없다면 방문한다.
        if(!visited[there])
            dfs(there);
    }
    // 더이상 방문할 정점이 없으니, 재귀 호출을 종료하고 이전 정점으로 돌아간다.
}

// 모든 정점을 방문한다.
void dfsAll(){
    // visited를 모두 false로 초기화한다.
    visited = vector<bool>(adj.size(), false);
    // 모든 정점을 순회하면서, 아직 방문한 적 없으면 방문한다.
    for(int i = 0; i < adj.size(); ++i)
        if(!visited[i])
            dfs(i);
}
```

- dfsAll()이 존재하는 이유: 모든 정점들이 간선을 통해 연결되어 있다는 보장이 없기 때문입니다.
- 시간 복잡도: **O(|V| + |E|)** -> 한 정점마다 한 번씩 호출됩니다. 모든 정점에 대해 dfs를 수행하면 모든 간선을 한번(방향 그래프) 혹은 두번(무향 그래프) 확인할 수 있습니다. 그러나, **인접 배열을 사용하게 된다면 두 정점 사이에 간선이 있는 지를 확인해야 되기 때문에 O(V^2)의 시간이 걸리게 됩니다.**

## 위상정렬

- dfs에서 풀 수 있는 가장 유명한 문제 중 하나로, 의존성이 있는 작업들이 주어질 때, 이들이 어떠한 순서대로 수행해야 하는 지를 계산해 줍니다.
- 위상정렬의 조건: **모든 간선의 방향 혹은 흐름에 일관성**이 있어야 한다.

![위상정렬 1](https://mblogthumb-phinf.pstatic.net/20160830_216/kks227_1472490641094kuBx3_PNG/1.png?type=w2)

- 다음과 같은 그래프의 위상정렬을 만들어봅시다.
- A -> B, B -> C, C -> D, B -> D

![위상정렬 2](https://mblogthumb-phinf.pstatic.net/20160830_134/kks227_1472490641376hrX1i_PNG/2.png?type=w2)

![위상정렬 3](https://mblogthumb-phinf.pstatic.net/20160830_251/kks227_1472490641548MYHPY_PNG/3.png?type=w2)

- 위의 그림은 위상정렬이지만, 아래는 아닙니다.
- 위상정렬의 조건 -> 사이클이 존재해서는 안됩니다. 그 이유는 흐름에 역행해야 하는 간선이 무조건 존재하기 때문입니다. 이를 사이클이 없는 방향그래프인 **DAG**(Directed acyclic graph)라고 부릅니다.
- 결국 위상정렬 === DAG의 정점을 배열하는 문제

#### 어떻게 하면 구현할 수 있을까?

- 들어오는 간선이 하나도 없는 정점을 선택한 다음, 이를 Queue에 넣고, 제거하는 방식대로 구현하면 된다.

[위상정렬 풀이](https://ongveloper.tistory.com/136)

## 오일러 서킷

- 그래프의 모든 간선을 정확히 '**한번씩**' 지나서 **시작점으로 돌아오는** 경로를 찾는 문제를 오일러 서킷이라고 부릅니다.
- 가장 대표적으로 '**한붓그리기**'가 있습니다.
- 일단 **'무향그래프'에 대해서 오일러 서킷이 존재하는지 확인**해 봅시다.
- 오일러서킷 존재하는 경우 -> 찾아주면 끝
- 오일러서킷 존재하지 않는 경우 -> 경로가 모든 간선을 지나지 못하고 끝나게 됨 -> **시작점을 u, 끝점을 v**라고 가정
- v에 인접한 간선은 **모두 지난 상태**
- 두 개의 케이스가 존재합니다.
  - 시작점과 끝점이 일치하지 X : **v의 간선은 홀수 개(들어옴, 들어왔다 나갔다 들어옴, 들나들나들, ...)** -> 들어와서 더 이상 나갈 수 없습니다.
  - 시작점과 끝점이 일치하는 경우 : **v의 간선은 짝수 개** 그 이유는 시작점에서 나가는 것으로 시작하기 때문 (나들, **나들나들, ...)**
- 역으로, 홀수점이라면 오일러 서킷이 존재하지 않는다. -> 오일러 서킷이라면 모든 정점이 짝수이다.
- **한 정점에 인접한 간선의 수를 해당 정점의 '차수'라고 부릅니다.**
- 오일러서킷 -> 모든 정점에 들어가는 횟수와 나가는 횟수가 일치해야 한다 -> **홀수점에서는 이것이 불가능하다.** (이유: 하나의 정점이 있을 때, 나가는 횟수 <= 들어오는 횟수)
- 모든 정점이 짝수점이면서, 간선들이 하나의 컴포넌트에 포함된 그래프가 주어진 경우에는 항상 서킷을 찾아내는 알고리즘을 만들어낼 수 있습니다.

```C++
// dfs를 이용한 오일러 서킷 찾기

//그래프의 인접 행렬 표현 adj[i][j] : i와 j사이의 간선 수
vector<vector<int> > adj;
//무향 그래프에서 오일러 서킷 탐색
void getEulerCurcuit(int here, vector<int> &curcuit){
    for(int there = 0; there < adj[here].size(); ++there){
        while(adj[here][there] > 0){
            adj[here][there]--;
            adj[there][here]--;//유향 그래프일 경우 이것을 지우면 된다
            getEulerCurcuit(there,curcuit);
        }
    curcuit.push_back(here);
}
```

![오일러서킷](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9995644F5C739C471C)

## 해밀토니안 경로

- 그래프의 **모든 정점을 정확히 한 번씩** 지나는 경로를 해밀토니안 경로라고 부릅니다.
- 해밀토니안 경로의 개념은 이해하기 쉽고 직관적이지만, 큰 그래프에 대해 해밀토니안 경로를 빠르게 찾는 방법은 아직 고안되지 않았으며, 유일하게 해밀토니안 경로를 찾는 방법은 바로 '조합 탐색'을 이용하는 것뿐입니다.

## 오일러 트레일

- 오일러 서킷처럼 모든 간선을 정확히 한번만 지나가지만, 시작점과 끝점이 다른 경로를 '오일러 트레일'이라고 부릅니다.
- 방법은 간단합니다.
- a -> ... -> b (a: 시작점, b: 끝점)
- **(a, b)사이에 간선을 추가한 뒤, 오일러 서킷을 찾습니다. -> 그 다음에 (a, b) 간선을 지우면 오일러 트레일이 됩니다.**
  - a -> ... -> b -> a ((a, b) 간선이 존재하기 때문)
  - a -> ... -> b ((a, b) 간선을 지움)
- 오일러 트레일의 전제 조건: **a, b를 제외한 모든 점은 짝수점, a와 b는 홀수점이어야 합니다.**

## dfs 스패닝 트리

- 어떤 그래프를 dfs를 이용하여 탐색했을 때, **탐색이 따라가는 간선들만을 모아 보면 트리의 형태**를 띄게 됩니다.

![dfs 스패닝 1](https://ifh.cc/g/fP2Nfo.png)

- 다음과 같은 트리가 있다고 가정해보겠습니다.

![dfs 스패닝 2](https://ifh.cc/g/jqJvza.png)

- dfs는 다음과 같은 탐색을 가지게 됩니다.
  - 1.  초록색: 0 -> 1 -> 2를 탐색
  - 2.  주황색: 0 -> 4를 탐색
  - 3.  파란색: 0 -> 5 -> 3을 탐색
  - 4.  보라색: 5 -> 6을 탐색
- 결과: 굵은 실선이 0번 정점을 루트 노드로 하는 트리가 생성된다 -> **dfs 스패닝 트리**

## 절단점 찾기 알고리즘

- 무향 그래프를 기준으로 '절단점'이란 이 점과 인접한 간선들을 보두 지웠을 때 해당 컴포넌트가 두 개 이상으로 나뉘어지는 정점을 말합니다.

![절단점 찾기 트리](https://ifh.cc/g/D0BS2n.png)

- 다음과 같은 그래프에서 1, 3, 5번이 절단점에 해당합니다.
- 절단점 알고리즘은 실생활에서도 중요하게 쓰일 수 있습니다. (예시: 지하철 노선, 네트워크 라우터)

### 어떻게 하면 절단점을 찾을 수 있을까?

- 1. 가장 먼저 임의의 정점을 하나 선택하고, dfs 스패닝 트리를 생성합니다.
- 2. dfs 스패닝 트리는 **교차 간선이 존재하지 않습니다.** 즉, 하나의 노드를 구성하는 각각의 서브트리가 있을 경우, 각각의 서브트리를 이어주는 간선이 존재하지 않습니다.
- 3. 결국 임의의 노드를 선택했을 때, 해당 노드는 **해당 노드의 조상 혹은 자손끼리만 연결**됩니다.

![절단점 찾기 2](https://ifh.cc/g/8DlmXX.jpg)

- u가 지워졌을 때 그래프가 쪼개지지 않는 유일한 경우 === u의 선조와 자손들이 **전부 역방향 간선으로 연결**되어 있을 경우
- u가 만약에 루트 노드라면? 무조건 절단점이 아닌가? -> 자손이 하나도 없는 경우, 혹은 하나밖에 없는 경우에는 u가 없어져도 그래프는 쪼개지지 않습니다.

### 알고리즘 구현 방식

```C++
// 그래프의 인접 리스트 표현
vector<vector<int> > adj;

// 각 정점의 발견 순서를 -1로 초기화합니다.
vector<int> discovered;

// 각 정점이 절단점인지 여부를 저장하고, false로 초기화합니다.
vector<bool> isCutVertex;
int counter = 0;

// here를 루트로 하는 서브트리에 있는 절단점들을 찾습니다.
// 반환값은 해당 서브트리에서 역방향 간선으로 갈 수 있는 정점 중
// 가장 일찍 발견된 정점의 발견 시점입니다.
// 처음 호출되는 경우에는 isRoot = true로 설정합니다.
int findCutVertex(int here, bool isRoot) {
	// 발견 순서를 기록합니다.
	discovered[here] = counter++;
	int ret = discovered[here]

	// 루트인 경우의 절단점 판정을 위해 자손 서브트리의 개수를 샙니다.
	int children = 0;
	for (int i = 0; i < adj[here].size(); ++i) {
		int there = adj[here][i]

		// 아직 발견되지 않은 경우 (자식 노드)
		if (discovered[there] == -1) {
			++children;

			// 이 서브트리에서 갈 수 있는 가장 높은 정점의 번호
			int subtree = findCutVertex(there, false);

			// 그 노드가 자기 자신 이하에 있다면 현재 위치는 절단점!
			if (!isRoot && subtree >= discovered[here])
				isCutVertex[here] = true;
			ret = min(ret, subtree)
		}
		// 이미 발견된 경우 (조상 노드)
		else
			ret = min(ret, discovered[there]);
	}
	// 루트인 경우 절단점의 판정은 서브트리의 개수로 한다.
	if (isRoot) isCutVertex[here] = (children >= 2);
	return ret
}
```

## 다리 찾기

- 절단점을 찾는 문제와 비슷하지만 다른 문제로 '다리 찾기' 문제가 있습니다.
- 어떤 간선을 삭제했을 때, **이 간선을 포한하던 컴포넌트가 두 개의 컴포넌트로 쪼개진다면**, 이 간선을 '다리(bridge)'라고 부를 수 있습니다.
- 절단점 찾기 알고리즘을 간단히 변경하면 문제를 풀 수 있습니다.

![다리 찾기](https://ifh.cc/g/aks8JY.png)
![다리인 경우와 그렇지 않은 경우](https://ifh.cc/g/aslbVb.jpg)

## 강결합 컴포넌트 분리

- 방향 그래프에서 정의되는 개념으로 '강결합 컴포넌트(strongly connected components, SCC)'가 있습니다.
- 방향 그래프 상에서 두 정점 u, v에 대해 양 방향으로 가능 경로가 모두 있을 때, 두 정점은 같은 SCC에 속해 있다고 말합니다.

![SCC 예시](https://ifh.cc/g/V0o19X.jpg)

- 방향 그래프에서 각 SCC 사이를 연결하는 간선들을 모으면, SCC들을 정점으로 하는 DAG(Directed Acyclic Graph)를 만들 수 있습니다.

![SCC, DAG 1](https://mblogthumb-phinf.pstatic.net/20140907_248/infoefficien_1410080471272pw7SS_PNG/%C1%A6%B8%F1_%BE%F8%C0%BD.png?type=w2)

![SCC, DAG 2](https://mblogthumb-phinf.pstatic.net/20140907_249/infoefficien_1410080729512TTbaD_PNG/%C1%A6%B8%F1_%BE%F8%C0%BD.png?type=w2)

## 타잔 알고리즘

- SCC를 구하는 대표적인 알고리즘으로 **'타잔 알고리즘'**이 있습니다. 한번 예시를 보면서 SCC를 구하는 방법에 대해 생각해봅시다.
- 타잔 알고리즘을 이용해서 시간 복잡도를 구하면 O(|v| + |e|)가 됩니다.
  ![타잔 1](https://ifh.cc/g/aG4jfq.png)
  ![타잔 2](https://ifh.cc/g/L8m0wn.jpg)
  ![타잔 3](https://ifh.cc/g/t1S6Ks.jpg)
  ![타잔 4](https://ifh.cc/g/7aGVtz.jpg)
  ![타잔 5](https://ifh.cc/g/AdDbB8.jpg)

## SAT 문제

- 참이냐, 거짓이냐의 결정을 여러 번 해야 하는 문제들은 불린 값 만족성 문제(Boolean Satisfiability problem, 혹은 SAT)로 모델링할 수 있습니다.
- SAT 문제는 불린 값의 참의 형태와 거짓 형태로 구성된 식이 주어질 때, 이 식의 값을 참으로 하는 변수의 조합이 있는 지 찾는 것입니다.

#### 예시: a && (!b || !a) && (c && (!a || b))

- 이 식이 참이 되기 위해서는 어떻게 해야 할까요?
  - a가 참이어야만 합니다.
  - (!b || !a)가 참이어야만 합니다. a는 참입니다. -> !a는 거짓입니다 -> !b는 참입니다. -> b는 거짓입니다.
  - (c && (!a || b))가 참이어야만 합니다. -> (!a || b)가 참입니다. -> !a는 거짓, b도 거짓입니다.
- 따라서 이 식의 참은 존재하지 않습니다.
- **2-SAT:** 논리식을 논리곱 정규형으로 표현했을 때 각 절에 두 개의 변수만이 존재하는 경우를 말합니다.
- 2-SAT가 될 경우에는 그래프 형태로 문제를 풀 수 있습니다.

링크: https://m.blog.naver.com/kks227/220803009418
