# 최단 경로 알고리즘

**최단 경로 알고리즘**은 주어진 그래프에서 주어진 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 알고리즘입니다.

가중치가 없는 그래프에서는 너비 우선 탐색으로 구할 수 있었습니다.

여기서는 가중치가 있는 그래프만을 다루며, 음수 가중치를 갖는 간선이 있을 수 있습니다.

**다만, 음수 사이클이 존재하는 경우 최단 거리를 구할 수 없습니다.**

![음수 사이클](imgs/1.png)

<br>

최단 경로 알고리즘은 **단일 시작점 알고리즘**과 **모든 쌍 알고리즘**으로 나뉩니다.

<br>

**단일 시작점 알고리즘**은 너비 우선 탐색을 기반으로 설계돼 있습니다.

하나의 시작점과 그 시작점으로부터 나머지 각 정점들까지의 최단 거리를 모두 구합니다.

계산 결과는 $V$ 크기의 1차원 배열이 됩니다.

<br>

**모든 쌍 알고리즘**은 모든 정점의 쌍에 대해 최단 거리를 계산합니다.

모든 정점들 간의 최단 거리를 모두 계산합니다.

계산 결과는 $V \times V$ 크기의 2차원 배열이 됩니다.

<br>

또한, 우리가 다룰 알고리즘들은 모두 방향 그래프를 기준으로 동작합니다.

무방향 그래프의 최단 거리를 구하려면 양방향 간선을 두 개의 일방향으로 쪼개면 됩니다.

이 때, 무방향 음수 간선이 있으면 음수 사이클이 발생하므로 최단 경로를 구할 수 없습니다.

<br>

## 다익스트라

**다익스트라 알고리즘**은 단일 시작점 최단 경로 알고리즘입니다.

음수 간선이 없는 경우에만 사용할 수 있습니다.

기본적인 아이디어는 너비 우선 탐색과 동일하며, 너비 우선 탐색과 달리 *우선순위 큐*를 사용합니다.

정점의 개수가 $V$, 간선의 개수가 $E$일 때, 다익스트라 알고리즘의 시간복잡도는 $O(ElgV)$입니다.

<br>

### 작동방식

우선순위 큐에는 정점과, 시작점으로부터 그 정점까지의 최단거리 값이 한 쌍으로 들어갑니다.

그리고 최단거리 값의 오름차순으로 정렬이 됩니다.

맨 처음에는 시작점과 0의 값이 한 쌍으로 들어갑니다.

그리고 인접한 정점들을 모두 검사하며 최단거리를 갱신하고, 우선순위 큐에 넣어줍니다.

구체적으로는 아래의 과정을 거칩니다.

1. 시작점으로부터 각 정점까지의 최단 거리를 저장하는 배열 `dist[]`를 `inf`로 초기화합니다.
1. `dist[src]`의 값을 `0`으로 대입합니다. (시작점)
1. 우선순위 큐에 `(src, 0)`을 삽입합니다.
1. 우선순위 큐가 다 비어질 때까지 다음을 반복합니다.
    1. 우선순위 큐에서 현재 정점과 현재 최단 거리 쌍을`(here, cost)` 꺼냅니다.
    1. 만약 `dist[here]`가 현재 `cost`보다 작다면 지금 꺼낸 것을 무시합니다.
    1. 현재 정점에 인접한 정점들을 모두 검사합니다.
        1. 이웃 정점(`there`)까지의 거리를 갱신합니다.
        1. 그 거리가 `dist[there]`에 저장된 값보다 짧다면 우선순위 큐에 해당 정점을 삽입합니다.
1. 위 과정을 마치면 `dist[]`에는 최단 거리가 모두 저장됩니다.

[이러한 과정을 잘 보여주는 그림을 봅시다.](https://m.blog.naver.com/kks227/220796029558?view=img_1)

[코드는 이렇게 작성됩니다.](dijkstra.cc)

## 플루이드 와샬

## 벨만-포드

## 문제 풀이

> ### 관련 문제 목록 바로가기
>
> [solved.ac](https://solved.ac/search?query=(%23dijkstra%20%7C%20%23floyd_warshall%20%7C%20%23bellman_ford))
> |
> [LeetCode](https://leetcode.com/problemset/all/?topicSlugs=shortest-path)

김하진: 

김재헌: 

박상준: 

박진영: 

서민혁: 

유태정: 

이재혁: 

이성구: 

조민준: 

정준우: 

한태혁: 
